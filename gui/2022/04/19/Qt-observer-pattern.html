<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Qt Observer Pattern | Cool Wind on Study</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="Qt Observer Pattern">
<meta name="author" content="CoolWind">
<meta property="og:locale" content="en_US">
<meta name="description" content="Reference Links Qt for Beginners The observer pattern Nearly all UI toolkits have a mechanism to detect an user action, and respond to this action. Some of them use callbacks, other use listeners, but basically, all of them are inspired by the observer pattern. Observer pattern is used when an observable object wants to notify other observers objects about a state change. An user has clicked on a button -&gt; a menu should be displayed A web page just finished loading -&gt; a process should extract some information from this loaded page. An user is scrolling through a list of items(in an app store for example) -&gt; reached the end, so other items should be loaded Observer pattern is used everywhere in GUI applications, And often leads to some boilerplate code (duplicate code). Qt was created with the idea of removing this boilerplate code and providing a nice and clean syntax, And the signal and slots mechanism is the answer. Signals and slots Instead of having observable objects and observers, and registering them, Qt provides two high level concepts: signals and slots. A signal is a message that object can send most of the time to inform of a status change A slots is a function (handler?) that is used to accept and respond to a signal Examples from QPushButton class. Signals clicked (pressed &amp; released) pressed released Slots QApplication::quit QWidget::setEnabled QPushButton::setText In order to respond to a signal, a slot must be connected to a signal. Qt provides the method QObject::connect. It is used this way, with the two macros SIGNAL and SLOT FooObjectA *fooA = new FooObjectA(); FooObjectB *fooB = new FooObjectB(); QObject::connect(fooA, SIGNAL (bared()), fooB, SLOT (baz())); assuming that FooObjectA have a bared signal, and FooObjectB have a baz slot. write signature of the signal and the slot inside the two macros SIGNAL and SLOT. Remark: Basically, signals and slots are methods, that might or might not have arguments, but that never return anything. While the notion of a signal as a method is unusual, a slot is actually a real method, and can be called as usual in other methods, or whilst responding to a signal. Transmitting information The signals and slots mechanism is useful to respond to buttons clicks, but it can do much more than that. For example, it can also be used to communicate information. While playing song, a progress bar is needed to show how much time remains before the song is over. A media player might have a class that is used to check the progress of the media. An instance of this class might periodically send a tick signal, with the progress value. This signal can be connected to a QProgressBar, that can be used to display the progress. The hypothetical class used to check the progress might have a signal that have this signature: void MediaProgressManager::tick(int ms); and we know from the documentation, that the QProgressBar has this slot: void QProressBar::setValue(int value); You can see that the signal and the slot have the same kind of parameters, especially the type int. If you connect a signal to a slot that does not share the same kind of parameters, when the connection is done (at run-time) you will get a warning like: QObject::connect: Incompatible sender/receiver arguments This is because the signal transmits the information to the slot using the parameters. The first parameter of the signal is passed to the first one of the slot, and the same for second, third, and so forth. The code for the connection will look like this: MediaProgressManager *manager = new MediaProgressManager(); QProgressBar *progress = new QProgressBar(window); QObject::connect(manager, SIGNAL (tick(int)), progress, SLOT (setValue(int)) ); You can see that you have to provide a signature inside the SIGNAL and SLOT macro, providing the type of values that are passed through the signals. You may also provide the name of the variable if you want. (It is actually even better). Feature of signals and slots A signal can be connected to several slots Many signals can be connected to a slot A signal can be connected to a signal: it is signal relaying. The second is sent if the first signal is sent Examples Responding to an event QPushButton provides the clicked signal. QApplication provides the quit slot, that closes the application. In order to make a click on a button close the app, we have to connect the signal clicked of the button to the quit slot of QApplication instance. How to access to the QApplication instance while you are in another class. There exists a static function in QApplication, with the following signature, that is used to get it: QApplication * QApplication::instance() This leads to the following modification of our previous code: ```window.cpp #include “window.h” #include #include Window::Window(QWidget *parent) : QWidget(parent) { // Set size of the window setFixedSize(100, 50); // Create and position the button m_button = new QPushButton(“Hello World”, this); m_button-&gt;setGeometry(10, 10, 80, 30); // New : Do the connection connect(m_button, SIGNAL (clicked()), QApplication::instance(), SLOT (quit()) ); } ``` While clicking on the button inside of the window, the application should quit. Transmitting information with signals and slots Simpler example for information transmission. Only displays a progress bar and a slider (created by QSlider) inside a window, and while the slider is moved, the value of the progress bar is synced with a very simple connection. void QSlider::valueChanged(int value); void QProgressBar::setValue(int value); QSlider automatically emits the signal valueChanged with the new value passed as a parameter when the value is changed, and the method setValue of QProgressBar, is used to set the value of the progress bar. #include &lt;QApplication&gt; #include &lt;QProgressBar&gt; #include &lt;QSlider&gt; int main(int argc, char **argv) { QApplication app(argc, argv); // Create a container window Window window; window.setFixedSize(200, 140); // Create a progress bar // with the range between 0 and 100, and a starting value of 0 QProgressBar* progressBar = new QProgressBar(&amp;window); progressBar-&gt;setRange(0, 100); progressBar-&gt;setValue(0); progressBar-&gt;setGeometry(10, 50, 180, 30); // Create a horizontal slider // with the range between 0 and 100, and a starting value of 0 QSlider* slider = new QSlider(&amp;window); slider-&gt;setOrientation(Qt::Horizontal); slider-&gt;setRange(0, 100); slider-&gt;setValue(0); slider-&gt;setGeometry(10, 90, 180, 30); window.show(); // Connection // This connection set the value of the progress bar // while the slider's value changes QObject::connect( slider, SIGNAL (valueChanged(int)), progressBar, SLOT (setValue(int)) ); return app.exec(); }">
<meta property="og:description" content="Reference Links Qt for Beginners The observer pattern Nearly all UI toolkits have a mechanism to detect an user action, and respond to this action. Some of them use callbacks, other use listeners, but basically, all of them are inspired by the observer pattern. Observer pattern is used when an observable object wants to notify other observers objects about a state change. An user has clicked on a button -&gt; a menu should be displayed A web page just finished loading -&gt; a process should extract some information from this loaded page. An user is scrolling through a list of items(in an app store for example) -&gt; reached the end, so other items should be loaded Observer pattern is used everywhere in GUI applications, And often leads to some boilerplate code (duplicate code). Qt was created with the idea of removing this boilerplate code and providing a nice and clean syntax, And the signal and slots mechanism is the answer. Signals and slots Instead of having observable objects and observers, and registering them, Qt provides two high level concepts: signals and slots. A signal is a message that object can send most of the time to inform of a status change A slots is a function (handler?) that is used to accept and respond to a signal Examples from QPushButton class. Signals clicked (pressed &amp; released) pressed released Slots QApplication::quit QWidget::setEnabled QPushButton::setText In order to respond to a signal, a slot must be connected to a signal. Qt provides the method QObject::connect. It is used this way, with the two macros SIGNAL and SLOT FooObjectA *fooA = new FooObjectA(); FooObjectB *fooB = new FooObjectB(); QObject::connect(fooA, SIGNAL (bared()), fooB, SLOT (baz())); assuming that FooObjectA have a bared signal, and FooObjectB have a baz slot. write signature of the signal and the slot inside the two macros SIGNAL and SLOT. Remark: Basically, signals and slots are methods, that might or might not have arguments, but that never return anything. While the notion of a signal as a method is unusual, a slot is actually a real method, and can be called as usual in other methods, or whilst responding to a signal. Transmitting information The signals and slots mechanism is useful to respond to buttons clicks, but it can do much more than that. For example, it can also be used to communicate information. While playing song, a progress bar is needed to show how much time remains before the song is over. A media player might have a class that is used to check the progress of the media. An instance of this class might periodically send a tick signal, with the progress value. This signal can be connected to a QProgressBar, that can be used to display the progress. The hypothetical class used to check the progress might have a signal that have this signature: void MediaProgressManager::tick(int ms); and we know from the documentation, that the QProgressBar has this slot: void QProressBar::setValue(int value); You can see that the signal and the slot have the same kind of parameters, especially the type int. If you connect a signal to a slot that does not share the same kind of parameters, when the connection is done (at run-time) you will get a warning like: QObject::connect: Incompatible sender/receiver arguments This is because the signal transmits the information to the slot using the parameters. The first parameter of the signal is passed to the first one of the slot, and the same for second, third, and so forth. The code for the connection will look like this: MediaProgressManager *manager = new MediaProgressManager(); QProgressBar *progress = new QProgressBar(window); QObject::connect(manager, SIGNAL (tick(int)), progress, SLOT (setValue(int)) ); You can see that you have to provide a signature inside the SIGNAL and SLOT macro, providing the type of values that are passed through the signals. You may also provide the name of the variable if you want. (It is actually even better). Feature of signals and slots A signal can be connected to several slots Many signals can be connected to a slot A signal can be connected to a signal: it is signal relaying. The second is sent if the first signal is sent Examples Responding to an event QPushButton provides the clicked signal. QApplication provides the quit slot, that closes the application. In order to make a click on a button close the app, we have to connect the signal clicked of the button to the quit slot of QApplication instance. How to access to the QApplication instance while you are in another class. There exists a static function in QApplication, with the following signature, that is used to get it: QApplication * QApplication::instance() This leads to the following modification of our previous code: ```window.cpp #include “window.h” #include #include Window::Window(QWidget *parent) : QWidget(parent) { // Set size of the window setFixedSize(100, 50); // Create and position the button m_button = new QPushButton(“Hello World”, this); m_button-&gt;setGeometry(10, 10, 80, 30); // New : Do the connection connect(m_button, SIGNAL (clicked()), QApplication::instance(), SLOT (quit()) ); } ``` While clicking on the button inside of the window, the application should quit. Transmitting information with signals and slots Simpler example for information transmission. Only displays a progress bar and a slider (created by QSlider) inside a window, and while the slider is moved, the value of the progress bar is synced with a very simple connection. void QSlider::valueChanged(int value); void QProgressBar::setValue(int value); QSlider automatically emits the signal valueChanged with the new value passed as a parameter when the value is changed, and the method setValue of QProgressBar, is used to set the value of the progress bar. #include &lt;QApplication&gt; #include &lt;QProgressBar&gt; #include &lt;QSlider&gt; int main(int argc, char **argv) { QApplication app(argc, argv); // Create a container window Window window; window.setFixedSize(200, 140); // Create a progress bar // with the range between 0 and 100, and a starting value of 0 QProgressBar* progressBar = new QProgressBar(&amp;window); progressBar-&gt;setRange(0, 100); progressBar-&gt;setValue(0); progressBar-&gt;setGeometry(10, 50, 180, 30); // Create a horizontal slider // with the range between 0 and 100, and a starting value of 0 QSlider* slider = new QSlider(&amp;window); slider-&gt;setOrientation(Qt::Horizontal); slider-&gt;setRange(0, 100); slider-&gt;setValue(0); slider-&gt;setGeometry(10, 90, 180, 30); window.show(); // Connection // This connection set the value of the progress bar // while the slider's value changes QObject::connect( slider, SIGNAL (valueChanged(int)), progressBar, SLOT (setValue(int)) ); return app.exec(); }">
<link rel="canonical" href="coolwindjo.github.io/gui/2022/04/19/Qt-observer-pattern.html">
<meta property="og:url" content="coolwindjo.github.io/gui/2022/04/19/Qt-observer-pattern.html">
<meta property="og:site_name" content="Cool Wind on Study">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-04-19T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Qt Observer Pattern">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CoolWind"},"dateModified":"2022-04-19T00:00:00+00:00","datePublished":"2022-04-19T00:00:00+00:00","description":"Reference Links Qt for Beginners The observer pattern Nearly all UI toolkits have a mechanism to detect an user action, and respond to this action. Some of them use callbacks, other use listeners, but basically, all of them are inspired by the observer pattern. Observer pattern is used when an observable object wants to notify other observers objects about a state change. An user has clicked on a button -&gt; a menu should be displayed A web page just finished loading -&gt; a process should extract some information from this loaded page. An user is scrolling through a list of items(in an app store for example) -&gt; reached the end, so other items should be loaded Observer pattern is used everywhere in GUI applications, And often leads to some boilerplate code (duplicate code). Qt was created with the idea of removing this boilerplate code and providing a nice and clean syntax, And the signal and slots mechanism is the answer. Signals and slots Instead of having observable objects and observers, and registering them, Qt provides two high level concepts: signals and slots. A signal is a message that object can send most of the time to inform of a status change A slots is a function (handler?) that is used to accept and respond to a signal Examples from QPushButton class. Signals clicked (pressed &amp; released) pressed released Slots QApplication::quit QWidget::setEnabled QPushButton::setText In order to respond to a signal, a slot must be connected to a signal. Qt provides the method QObject::connect. It is used this way, with the two macros SIGNAL and SLOT FooObjectA *fooA = new FooObjectA(); FooObjectB *fooB = new FooObjectB(); QObject::connect(fooA, SIGNAL (bared()), fooB, SLOT (baz())); assuming that FooObjectA have a bared signal, and FooObjectB have a baz slot. write signature of the signal and the slot inside the two macros SIGNAL and SLOT. Remark: Basically, signals and slots are methods, that might or might not have arguments, but that never return anything. While the notion of a signal as a method is unusual, a slot is actually a real method, and can be called as usual in other methods, or whilst responding to a signal. Transmitting information The signals and slots mechanism is useful to respond to buttons clicks, but it can do much more than that. For example, it can also be used to communicate information. While playing song, a progress bar is needed to show how much time remains before the song is over. A media player might have a class that is used to check the progress of the media. An instance of this class might periodically send a tick signal, with the progress value. This signal can be connected to a QProgressBar, that can be used to display the progress. The hypothetical class used to check the progress might have a signal that have this signature: void MediaProgressManager::tick(int ms); and we know from the documentation, that the QProgressBar has this slot: void QProressBar::setValue(int value); You can see that the signal and the slot have the same kind of parameters, especially the type int. If you connect a signal to a slot that does not share the same kind of parameters, when the connection is done (at run-time) you will get a warning like: QObject::connect: Incompatible sender/receiver arguments This is because the signal transmits the information to the slot using the parameters. The first parameter of the signal is passed to the first one of the slot, and the same for second, third, and so forth. The code for the connection will look like this: MediaProgressManager *manager = new MediaProgressManager(); QProgressBar *progress = new QProgressBar(window); QObject::connect(manager, SIGNAL (tick(int)), progress, SLOT (setValue(int)) ); You can see that you have to provide a signature inside the SIGNAL and SLOT macro, providing the type of values that are passed through the signals. You may also provide the name of the variable if you want. (It is actually even better). Feature of signals and slots A signal can be connected to several slots Many signals can be connected to a slot A signal can be connected to a signal: it is signal relaying. The second is sent if the first signal is sent Examples Responding to an event QPushButton provides the clicked signal. QApplication provides the quit slot, that closes the application. In order to make a click on a button close the app, we have to connect the signal clicked of the button to the quit slot of QApplication instance. How to access to the QApplication instance while you are in another class. There exists a static function in QApplication, with the following signature, that is used to get it: QApplication * QApplication::instance() This leads to the following modification of our previous code: ```window.cpp #include “window.h” #include #include Window::Window(QWidget *parent) : QWidget(parent) { // Set size of the window setFixedSize(100, 50); // Create and position the button m_button = new QPushButton(“Hello World”, this); m_button-&gt;setGeometry(10, 10, 80, 30); // New : Do the connection connect(m_button, SIGNAL (clicked()), QApplication::instance(), SLOT (quit()) ); } ``` While clicking on the button inside of the window, the application should quit. Transmitting information with signals and slots Simpler example for information transmission. Only displays a progress bar and a slider (created by QSlider) inside a window, and while the slider is moved, the value of the progress bar is synced with a very simple connection. void QSlider::valueChanged(int value); void QProgressBar::setValue(int value); QSlider automatically emits the signal valueChanged with the new value passed as a parameter when the value is changed, and the method setValue of QProgressBar, is used to set the value of the progress bar. #include &lt;QApplication&gt; #include &lt;QProgressBar&gt; #include &lt;QSlider&gt; int main(int argc, char **argv) { QApplication app(argc, argv); // Create a container window Window window; window.setFixedSize(200, 140); // Create a progress bar // with the range between 0 and 100, and a starting value of 0 QProgressBar* progressBar = new QProgressBar(&amp;window); progressBar-&gt;setRange(0, 100); progressBar-&gt;setValue(0); progressBar-&gt;setGeometry(10, 50, 180, 30); // Create a horizontal slider // with the range between 0 and 100, and a starting value of 0 QSlider* slider = new QSlider(&amp;window); slider-&gt;setOrientation(Qt::Horizontal); slider-&gt;setRange(0, 100); slider-&gt;setValue(0); slider-&gt;setGeometry(10, 90, 180, 30); window.show(); // Connection // This connection set the value of the progress bar // while the slider&#39;s value changes QObject::connect( slider, SIGNAL (valueChanged(int)), progressBar, SLOT (setValue(int)) ); return app.exec(); }","headline":"Qt Observer Pattern","mainEntityOfPage":{"@type":"WebPage","@id":"coolwindjo.github.io/gui/2022/04/19/Qt-observer-pattern.html"},"url":"coolwindjo.github.io/gui/2022/04/19/Qt-observer-pattern.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="/assets/images/cls.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="coolwindjo.github.io/feed.xml" title="Cool Wind on Study">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Cool Wind on Study" src="/assets/images/cls.png" onerror="this.style.display='none'">
  Cool Wind on Study
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">Qt Observer Pattern</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2022-04-19T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 19, 2022
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 9 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/tags.html#qt">#qt</a><a class="post-tag" href="/tags.html#observer-pattern">#observer-pattern</a><a class="post-tag" href="/tags.html#signal">#signal</a><a class="post-tag" href="/tags.html#slot">#slot</a>
</div></header>
<article class="post h-entry" itemscope itemtype="https://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="reference-links">Reference Links</h2>

<ul>
  <li><a href="https://wiki.qt.io/Qt_for_Beginners" target="_blank">Qt for Beginners</a></li>
</ul>

<h2 id="the-observer-pattern">The observer pattern</h2>

<ul>
  <li>Nearly all UI toolkits have a mechanism to detect an user action, and respond to this action.
    <ul>
      <li>Some of them use callbacks, other use listeners, but basically, all of them are inspired by the observer pattern.</li>
      <li>Observer pattern is used when an observable object wants to notify other observers objects about a state change.
        <ul>
          <li>An user has clicked on a button -&gt; a menu should be displayed</li>
          <li>A web page just finished loading -&gt; a process should extract some information from this loaded page.</li>
          <li>An user is scrolling through a list of items(in an app store for example) -&gt; reached the end, so other items should be loaded</li>
        </ul>
      </li>
      <li>Observer pattern is used everywhere in GUI applications,
        <ul>
          <li>And often leads to some boilerplate code (duplicate code).
            <ul>
              <li>Qt was created with the idea of removing this boilerplate code and providing a nice and clean syntax,</li>
              <li>And the signal and slots mechanism is the answer.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="signals-and-slots">Signals and slots</h2>

<ul>
  <li>Instead of having observable objects and observers, and registering them, Qt provides two high level concepts: <strong>signals</strong> and <strong>slots</strong>.
    <ul>
      <li>A <strong>signal</strong> is a message
        <ul>
          <li>that object can send</li>
          <li>most of the time to inform of a status change</li>
        </ul>
      </li>
      <li>A <strong>slots</strong> is a function (handler?)
        <ul>
          <li>that is used to accept and respond to a signal</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Examples from <a href="https://doc.qt.io/qt-5/qpushbutton.html" target="_blank">QPushButton</a> class.
    <ul>
      <li>Signals
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">clicked</code> (pressed &amp; released)</li>
          <li><code class="language-plaintext highlighter-rouge">pressed</code></li>
          <li><code class="language-plaintext highlighter-rouge">released</code></li>
        </ul>
      </li>
      <li>Slots
        <ul>
          <li><code class="language-plaintext highlighter-rouge">QApplication::quit</code></li>
          <li><code class="language-plaintext highlighter-rouge">QWidget::setEnabled</code></li>
          <li><code class="language-plaintext highlighter-rouge">QPushButton::setText</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>In order to respond to a signal, a <strong>slot</strong> must be <em>connected</em> to a <strong>signal</strong>.
    <ul>
      <li>Qt provides the method QObject::<strong>connect</strong>.
        <ul>
          <li>It is used this way, with the two macros <code class="language-plaintext highlighter-rouge">SIGNAL</code> and <code class="language-plaintext highlighter-rouge">SLOT</code>
</li>
        </ul>

        <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">FooObjectA</span> <span class="o">*</span><span class="n">fooA</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">FooObjectA</span><span class="p">();</span>
<span class="n">FooObjectB</span> <span class="o">*</span><span class="n">fooB</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">FooObjectB</span><span class="p">();</span>

<span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">fooA</span><span class="p">,</span> <span class="n">SIGNAL</span> <span class="p">(</span><span class="n">bared</span><span class="p">()),</span> <span class="n">fooB</span><span class="p">,</span> <span class="n">SLOT</span> <span class="p">(</span><span class="n">baz</span><span class="p">()));</span>
</code></pre></div>        </div>
        <ul>
          <li>assuming that <code class="language-plaintext highlighter-rouge">FooObjectA</code> have a <code class="language-plaintext highlighter-rouge">bared</code> signal, and <code class="language-plaintext highlighter-rouge">FooObjectB</code> have a <code class="language-plaintext highlighter-rouge">baz</code> slot.
            <ul>
              <li>write signature of the signal and the slot inside the two macros <em>SIGNAL</em> and <em>SLOT</em>.</li>
            </ul>
          </li>
          <li>
<strong>Remark</strong>: Basically, <em>signal</em>s and <em>slot</em>s are methods, that might or might not have arguments,
            <ul>
              <li>but that never return anything.</li>
            </ul>
          </li>
          <li>While the notion of a <em>signal</em> as a method is unusual,
            <ul>
              <li>a <em>slot</em> is actually a real method, and can be called as usual in other methods, or whilst responding to a <em>signal</em>.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="transmitting-information">Transmitting information</h2>

<ul>
  <li>The <em>signal</em>s and <em>slot</em>s mechanism is useful to respond to buttons clicks, but it can do much more than that.
    <ul>
      <li>For example, it can also be used to communicate information.
        <ul>
          <li>While playing song,
            <ul>
              <li>a progress bar is needed to show how much time remains before the song is over.</li>
              <li>A media player might have a class that is used to check the progress of the media.
                <ul>
                  <li>An instance of this class might periodically send a <em>tick</em> signal, with the progress value.
This <em>signal</em> can be connected to a  <a href="https://doc.qt.io/qt-5/qprogressbar.html" target="_blank">QProgressBar</a>, that can be used to display the progress.</li>
                  <li>The hypothetical class used to check the progress might have a <em>signal</em> that have this signature:
                    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">MediaProgressManager</span><span class="o">::</span><span class="n">tick</span><span class="p">(</span><span class="kt">int</span> <span class="n">ms</span><span class="p">);</span>
</code></pre></div>                    </div>
                  </li>
                  <li>and we know from the documentation, that the <a href="https://doc.qt.io/qt-5/qprogressbar.html" target="_blank">QProgressBar</a> has this slot:
                    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">QProressBar</span><span class="o">::</span><span class="n">setValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div>                    </div>
                  </li>
                  <li>You can see that the <em>signal</em> and the <em>slot</em> have the same kind of parameters, especially the <em>type</em> <strong>int</strong>.
                    <ul>
                      <li>If you connect a <em>signal</em> to a <em>slot</em> that does not share the same kind of parameters, when the connection is done (at run-time) you will get a warning like:
                        <blockquote>
                          <p>QObject::connect: Incompatible sender/receiver arguments</p>
                        </blockquote>
                      </li>
                      <li>This is because the <em>signal</em> transmits the information to the <em>slot</em> using the parameters.</li>
                      <li>The first parameter of the <em>signal</em> is passed to the first one of the <em>slot</em>, and the same for second, third, and so forth.</li>
                    </ul>
                  </li>
                  <li>The code for the connection will look like this:
                    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">MediaProgressManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MediaProgressManager</span><span class="p">();</span>
<span class="n">QProgressBar</span> <span class="o">*</span><span class="n">progress</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QProgressBar</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

<span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">SIGNAL</span> <span class="p">(</span><span class="n">tick</span><span class="p">(</span><span class="kt">int</span><span class="p">)),</span> <span class="n">progress</span><span class="p">,</span> <span class="n">SLOT</span> <span class="p">(</span><span class="n">setValue</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">);</span>
</code></pre></div>                    </div>
                    <ul>
                      <li>You can see that you have to provide a signature inside the <em>SIGNAL</em> and <em>SLOT</em> macro, providing the type of values that are passed through the <em>signal</em>s.
                        <ul>
                          <li>You may also provide the name of the variable if you want. (It is actually even better).</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="feature-of-signals-and-slots">Feature of signals and slots</h2>

<ul>
  <li>A <em>signal</em> can be connected to several <em>slots</em>
</li>
  <li>Many <em>signals</em> can be connected to a <em>slot</em>
</li>
  <li>A <em>signal</em> can be connected to a <em>signal</em>:
    <ul>
      <li>it is <em>signal</em> relaying.</li>
      <li>The second is sent if the first <em>signal</em> is sent</li>
    </ul>
  </li>
</ul>

<h2 id="examples">Examples</h2>

<ul>
  <li>Responding to an event
    <ul>
      <li>
<a href="https://doc.qt.io/qt-5/qpushbutton.html" target="_blank">QPushButton</a> provides the <em>clicked</em> signal.</li>
      <li>
<a href="https://doc.qt.io/qt-5/qapplication.html" target="_blank">QApplication</a> provides the <em>quit</em> slot, that closes the application.</li>
      <li>In order to make a click on a button close the app, we have to connect the signal <em>clicked</em> of the button to the <em>quit</em> slot of QApplication instance.</li>
      <li>How to access to the QApplication instance while you are in another class.
        <ul>
          <li>There exists a static function in <a href="https://doc.qt.io/qt-5/qapplication.html" target="_blank">QApplication</a>, with the following signature, that is used to get it:
            <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">QApplication</span> <span class="o">*</span> <span class="n">QApplication</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
</code></pre></div>            </div>
          </li>
          <li>This leads to the following modification of our previous code:
```window.cpp
#include “window.h”</li>
        </ul>

        <p>#include <qapplication>
#include <qpushbutton></qpushbutton></qapplication></p>

        <p>Window::Window(QWidget *parent) : QWidget(parent)
{
  // Set size of the window
  setFixedSize(100, 50);</p>

        <p>// Create and position the button
  m_button = new QPushButton(“Hello World”, this);
  m_button-&gt;setGeometry(10, 10, 80, 30);</p>

        <p>// New : Do the connection
  connect(m_button, SIGNAL (clicked()), QApplication::instance(), SLOT (quit()) );
}
```</p>
        <ul>
          <li>While clicking on the button inside of the window, the application should quit.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="transmitting-information-with-signals-and-slots">Transmitting information with signals and slots</h2>

<ul>
  <li>Simpler example for information transmission.
    <ul>
      <li>Only displays a progress bar and a slider (created by <a href="http://doc.qt.io/qt-5/qslider.html#" target="_blank">QSlider</a>) inside a window, and while the slider is moved, the value of the progress bar is synced with a very simple connection.
        <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">QSlider</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">QProgressBar</span><span class="o">::</span><span class="n">setValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
      <li>QSlider automatically emits the signal <code class="language-plaintext highlighter-rouge">valueChanged</code> with the new value passed as a parameter when the value is changed, and the method <code class="language-plaintext highlighter-rouge">setValue</code> of QProgressBar, is used to set the value of the progress bar.</li>
    </ul>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;QApplication&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QProgressBar&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QSlider&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="c1">// Create a container window</span>
  <span class="n">Window</span> <span class="n">window</span><span class="p">;</span>
  <span class="n">window</span><span class="p">.</span><span class="n">setFixedSize</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">140</span><span class="p">);</span>

  <span class="c1">// Create a progress bar</span>
  <span class="c1">// with the range between 0 and 100, and a starting value of 0</span>
  <span class="n">QProgressBar</span><span class="o">*</span> <span class="n">progressBar</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QProgressBar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window</span><span class="p">);</span>
  <span class="n">progressBar</span><span class="o">-&gt;</span><span class="n">setRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
  <span class="n">progressBar</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">progressBar</span><span class="o">-&gt;</span><span class="n">setGeometry</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

  <span class="c1">// Create a horizontal slider</span>
  <span class="c1">// with the range between 0 and 100, and a starting value of 0</span>
  <span class="n">QSlider</span><span class="o">*</span> <span class="n">slider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSlider</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window</span><span class="p">);</span>
  <span class="n">slider</span><span class="o">-&gt;</span><span class="n">setOrientation</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Horizontal</span><span class="p">);</span>
  <span class="n">slider</span><span class="o">-&gt;</span><span class="n">setRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
  <span class="n">slider</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">slider</span><span class="o">-&gt;</span><span class="n">setGeometry</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

  <span class="n">window</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

  <span class="c1">// Connection</span>
  <span class="c1">// This connection set the value of the progress bar</span>
  <span class="c1">// while the slider's value changes</span>
  <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span> <span class="n">slider</span><span class="p">,</span> <span class="n">SIGNAL</span> <span class="p">(</span><span class="n">valueChanged</span><span class="p">(</span><span class="kt">int</span><span class="p">)),</span> <span class="n">progressBar</span><span class="p">,</span> <span class="n">SLOT</span> <span class="p">(</span><span class="n">setValue</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">);</span>

  <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/programming/2022/03/10/design-pattern-builder.html" title="Design Pattern Builder">Design Pattern Builder</a><a class="next" href="/gui/2022/05/17/Qt-meta-object.html" title="Qt Meta Object">Qt Meta Object</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/ros/2020/10/08/ros-lecture.html" title="Qt Meta Object">ROS - ROBOTIS Lecture 1, 2, 4 (with Links)</a></li>
<li><a class="post-link" href="/blogging/2016/01/01/another-test-markdown.html" title="Qt Meta Object">Another test markdown</a></li>
<li><a class="post-link" href="/scripts/2021/12/27/yolox-docker.html" title="Qt Meta Object">Yolox Docker</a></li>
<li><a class="post-link" href="/blogging/2017/12/04/plantuml-example.html" title="Qt Meta Object">Plantuml example</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>2019-2022 @ CoolWind coolwind@hotmail.co.kr All rights reserved. Powered by <a href="https://jekyllrb.com/">Jekyll</a>
</div>
      <!-- <div>2019-{currentYear} @ {author} coolwind@hotmail.co.kr All rights reserved. Powered by <a href="https://jekyllrb.com/">Jekyll</a> <a href=https://github.com/coolwindjo/coolwindjo.github.io>@CoolWind</a></div> -->
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
